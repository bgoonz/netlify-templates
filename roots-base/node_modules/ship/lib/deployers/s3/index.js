// Generated by CoffeeScript 1.9.1
(function() {
  var AWS, W, _, check_config, create_bucket, create_client, create_site_config, destroy, errors, fs, mime, minimatch, nodefn, path, put_file, readdirp, remove_ignores, upload_files;

  path = require('path');

  fs = require('fs');

  W = require('when');

  nodefn = require('when/node/function');

  AWS = require('aws-sdk');

  _ = require('lodash');

  mime = require('mime');

  readdirp = require('readdirp');

  minimatch = require('minimatch');

  module.exports = function(root, config) {
    var client, ctx, d;
    d = W.defer();
    if (config.region == null) {
      config.region = 'us-east-1';
    }
    if (config.bucket == null) {
      config.bucket = root.split(path.sep).reverse()[0];
    }
    client = create_client(config);
    d.notify("Deploying " + root + " to Amazon S3");
    ctx = {
      d: d,
      client: client,
      config: config,
      root: root
    };
    check_config.call(ctx).then(upload_files.bind(ctx)).done(function() {
      return d.resolve({
        deployer: 's3',
        url: "http://" + config.bucket + ".s3-website-" + config.region + ".amazonaws.com",
        destroy: destroy.bind(ctx)
      });
    }, d.reject);
    return d.promise;
  };

  module.exports.config = {
    required: ['access_key', 'secret_key'],
    optional: ['region', 'bucket', 'ignore']
  };

  errors = {
    access_denied: "Access Denied: Either your credentials are incorrect, or your bucket name is already taken. Please verify your credentials and/or specify a different bucket name.",
    permanent_redirect: "Permanent Redirect: This probably means you have set an incorrect region. Make sure you're bucket's region matches what you set in the configuration."
  };

  create_client = function(config) {
    AWS.config.update({
      secretAccessKey: config.secret_key,
      accessKeyId: config.access_key,
      bucket: config.bucket,
      region: config.region
    });
    return new AWS.S3;
  };

  check_config = function() {
    return nodefn.call(this.client.getBucketWebsite.bind(this.client), {
      Bucket: this.config.bucket
    })["catch"]((function(_this) {
      return function(err) {
        switch (err.code) {
          case 'NoSuchBucket':
            return create_bucket.call(_this).then(create_site_config.bind(_this));
          case 'NoSuchWebsiteConfiguration':
            return create_site_config.call(_this);
          case 'AccessDenied':
            throw errors.access_denied;
            break;
          case 'PermanentRedirect':
            throw errors.permanent_redirect;
            break;
          default:
            throw err;
        }
      };
    })(this));
  };

  create_bucket = function() {
    this.d.notify("Creating bucket '" + this.config.bucket + "'...");
    return nodefn.call(this.client.createBucket.bind(this.client), {
      Bucket: this.config.bucket
    }).tap((function(_this) {
      return function() {
        return _this.d.notify('Bucket created');
      };
    })(this));
  };

  create_site_config = function() {
    var site_config;
    this.d.notify('Setting up static website configuration...');
    site_config = {
      Bucket: this.config.bucket,
      WebsiteConfiguration: {
        IndexDocument: {
          Suffix: 'index.html'
        }
      }
    };
    return nodefn.call(this.client.putBucketWebsite.bind(this.client), site_config).tap((function(_this) {
      return function() {
        return _this.d.notify('Static website configuration set up');
      };
    })(this));
  };

  upload_files = function() {
    return nodefn.call(readdirp, {
      root: this.root
    }).then((function(_this) {
      return function(res) {
        var files;
        files = _.pluck(remove_ignores(res.files, _this.config.ignore), 'path');
        return W.map(files, put_file.bind(_this));
      };
    })(this));
  };

  put_file = function(fpath, cb) {
    return nodefn.call(fs.readFile, path.join(this.root, fpath)).then((function(_this) {
      return function(contents) {
        return nodefn.call(_this.client.putObject.bind(_this.client), {
          Bucket: _this.config.bucket,
          Key: fpath,
          Body: contents,
          ACL: 'public-read',
          ContentType: mime.lookup(fpath)
        }).tap(function() {
          return _this.d.notify("uploaded " + fpath);
        });
      };
    })(this));
  };

  remove_ignores = function(files, ignores) {
    var f, j, len, mask;
    mask = [];
    for (j = 0, len = files.length; j < len; j++) {
      f = files[j];
      mask.push(_(ignores).map(function(i) {
        return minimatch(f.path, i);
      }).contains(true));
    }
    return files.filter(function(m, i) {
      return !mask[i];
    });
  };

  destroy = function() {
    return nodefn.call(this.client.listObjects.bind(this.client), {
      Bucket: this.config.bucket
    }).then((function(_this) {
      return function(data) {
        return nodefn.call(_this.client.deleteObjects.bind(_this.client), {
          Bucket: _this.config.bucket,
          Delete: {
            Objects: data.Contents.map(function(i) {
              return {
                Key: i.Key
              };
            })
          }
        });
      };
    })(this)).then((function(_this) {
      return function() {
        return nodefn.call(_this.client.deleteBucket.bind(_this.client), {
          Bucket: _this.config.bucket
        });
      };
    })(this));
  };

}).call(this);
