// Generated by CoffeeScript 1.9.1
(function() {
  var GithubApi, W, _, authenticate, build_tree, create_blob, create_branch, create_commit, create_initial_commit, create_tree, destroy, file_map, format_tree, fs, get_blob_sha, get_default_branch, get_latest_commit, get_tree_sha, guard, keys, minimatch, nodefn, path, readdirp, update_gh_pages_branch;

  path = require('path');

  fs = require('fs');

  W = require('when');

  nodefn = require('when/node');

  guard = require('when/guard');

  keys = require('when/keys');

  _ = require('lodash');

  readdirp = require('readdirp');

  GithubApi = require('github');

  minimatch = require('minimatch');

  file_map = require('file-map');

  module.exports = function(root, config) {
    var ctx, d, gh, repo_name, repo_user;
    d = W.defer();
    config.ignore = _.compact(['.gitignore', '.git{/**,}', '**/node_modules{/**,}'].concat(config.ignore));
    repo_user = config.repo.split('/')[0];
    repo_name = config.repo.split('/')[1];
    gh = new GithubApi({
      version: "3.0.0",
      debug: false
    });
    ctx = {
      root: root,
      gh: gh,
      config: config,
      user: repo_user,
      repo: repo_name,
      branch: config.branch || 'gh-pages'
    };
    authenticate.call(ctx)["with"](ctx).then(get_latest_commit).then(build_tree).then(create_commit).then(update_gh_pages_branch).done(function() {
      return d.resolve({
        deployer: 'gh-pages',
        url: "http://" + repo_user + ".github.io/" + repo_name,
        destroy: destroy.bind(this)
      });
    }, d.reject);
    return d.promise;
  };

  module.exports.config = {
    required: ['username', 'password', 'repo'],
    optional: ['ignore']
  };


  /**
   * Authenticates with github using the provided credentials
   * @return {Promise} - completed authentication, if incorrect, errors come later
   */

  authenticate = function() {
    this.gh.authenticate({
      type: 'basic',
      username: this.config.username,
      password: this.config.password
    });
    return W.resolve();
  };


  /**
   * Grabs the latest commit from the github pages branch. If this doesn't exist,
   * creates the branch with a commit for a basic readme.
   *
   * @return {Promise} a promise for the sha of the latest commit
   */

  get_latest_commit = function() {
    return nodefn.call(this.gh.repos.getCommits, {
      user: this.user,
      repo: this.repo,
      sha: this.branch
    }).then(function(res) {
      return res[0].sha;
    })["catch"]((function(_this) {
      return function(err) {
        var msg;
        msg = JSON.parse(err.message).message;
        if (msg === 'Git Repository is empty.') {
          return create_initial_commit.call(_this);
        }
        if (msg === 'Not Found') {
          return create_branch.call(_this);
        }
        throw err;
      };
    })(this));
  };


  /**
   * If a repo is empty, a commit needs to be created before trees can be pushed.
   * This method creates
   * @return {Promise} a promise for the sha of the newly created commit
   */

  create_initial_commit = function() {
    return nodefn.call(this.gh.repos.createFile, {
      user: this.user,
      repo: this.repo,
      branch: this.branch,
      message: 'initial commit',
      path: 'README.md',
      content: new Buffer(this.user + "/" + this.repo).toString('base64')
    }).then(function(res) {
      return res.sha;
    });
  };

  create_branch = function() {
    return get_default_branch.call(this).then((function(_this) {
      return function(branch) {
        return nodefn.call(_this.gh.gitdata.createReference, {
          user: _this.user,
          repo: _this.repo,
          ref: "refs/heads/" + _this.branch,
          sha: branch.commit.sha
        });
      };
    })(this));
  };

  get_default_branch = function() {
    return nodefn.call(this.gh.repos.getBranches, {
      user: this.user,
      repo: this.repo
    }).then(function(res) {
      return res[0];
    });
  };


  /**
   * Runs through the root and recrusively builds up the structure in the format
   * that github needs it. Creates blobs for files and trees at every folder
   * level, nesting them inside each other and returning a single tree object with
   * SHA's from github, ready to be committed.
   *
   * @return {Object} github-formatted tree object
   */

  build_tree = function() {
    var i;
    i = this.config.ignore;
    return file_map(this.root, {
      file_ignores: i,
      directory_ignores: i
    }).then((function(_this) {
      return function(tree) {
        return format_tree.call(_this, {
          path: '',
          children: tree
        });
      };
    })(this));
  };


  /**
   * This is the real workhorse. This method recurses through a given directory,
   * grabbing the files and folders and creating blobs and trees, nested properly,
   * through github's API.
   *
   * @param  {Object} root - a directory object provided by file-map
   * @return {Promise} a promise for a github-formatted tree object
   */

  format_tree = function(root) {
    var dirs, files;
    dirs = _.where(root.children, {
      type: 'directory'
    });
    files = _.where(root.children, {
      type: 'file'
    });
    if (dirs.length) {
      return W.map(dirs, format_tree.bind(this)).then((function(_this) {
        return function(dir_objects) {
          return W.map(files, create_blob.bind(_this)).then(function(file_objects) {
            return dir_objects.concat(file_objects);
          });
        };
      })(this)).then(create_tree.bind(this, root));
    } else {
      return W.map(files, create_blob.bind(this)).then(create_tree.bind(this, root));
    }
  };


  /**
   * Creates a blob through github's API, given a file.
   *
   * @param  {Object} file - file object via file-map
   * @return {Promise} promise for a github-formatted file object with the sha
   */

  create_blob = function(file) {
    return nodefn.call(fs.readFile, file.full_path).then(get_blob_sha.bind(this)).then(function(sha) {
      return {
        path: path.basename(file.path),
        mode: '100644',
        type: 'blob',
        sha: sha
      };
    });
  };


  /**
   * Creates a tree through github's API, given an array of contents.
   *
   * @param {Object} root - directory object via file-map of the tree's root dir
   * @param  {Array} tree - array of github-formatted tree and/or blob objects
   * @return {Promise} promise for a github-formatted tree object with the sha
   */

  create_tree = function(root, tree) {
    return get_tree_sha.call(this, tree).then(function(sha) {
      return {
        path: path.basename(root.path),
        mode: '040000',
        type: 'tree',
        sha: sha
      };
    });
  };


  /**
   * Given a file's content, creates a blob through github and returns the sha.
   *
   * @param  {String} content - the content of a file, as a utf8 string
   * @return {Promise} promise for a string representing the blob's sha
   */

  get_blob_sha = function(content) {
    return nodefn.call(this.gh.gitdata.createBlob.bind(this.gh), {
      user: this.user,
      repo: this.repo,
      content: content.toString('base64'),
      encoding: 'base64'
    }).then(function(res) {
      return res.sha;
    });
  };


  /**
   * Given a tree array, creates a tree through github and returns the sha.
   *
   * @param  {Array} tree - array containing tree and/or blob objects
   * @return {Promise} promise for a string representing the tree's sha
   */

  get_tree_sha = function(tree) {
    return nodefn.call(this.gh.gitdata.createTree.bind(this.gh), {
      user: this.user,
      repo: this.repo,
      tree: tree
    }).then(function(res) {
      return res.sha;
    });
  };


  /**
   * Given a tree, creates a new commit pointing to that tree.
   *
   * @param  {Object} tree - github-formatted tree object
   * @return {Promise} promise for github api's response to creating the commit
   */

  create_commit = function(tree) {
    return get_latest_commit.call(this).then((function(_this) {
      return function(sha) {
        return nodefn.call(_this.gh.gitdata.createCommit, {
          user: _this.user,
          repo: _this.repo,
          parents: [sha],
          tree: tree.sha,
          message: "deploy from ship"
        });
      };
    })(this));
  };


  /**
   * Points the deploy target branch's HEAD to the sha of a given commit.
   *
   * @param  {Object} commit - github api representation of a commit
   * @return {Promise} promise for the github api's response to updating the ref
   */

  update_gh_pages_branch = function(commit) {
    return nodefn.call(this.gh.gitdata.updateReference, {
      user: this.user,
      repo: this.repo,
      ref: "heads/" + this.branch,
      sha: commit.sha,
      force: true
    });
  };


  /**
   * Removes the deploy target branch, undoing the deploy.
   */

  destroy = function() {
    return nodefn.call(this.gh.gitdata.deleteReference, {
      user: this.user,
      repo: this.repo,
      ref: "heads/" + this.branch
    });
  };

}).call(this);
