// Generated by CoffeeScript 1.9.1
(function() {
  var Ship, W, _, fs, nodefn, path, prompt, yaml;

  path = require('path');

  fs = require('fs');

  yaml = require('js-yaml');

  prompt = require('./prompt');

  W = require('when');

  nodefn = require('when/node');

  _ = require('lodash');

  Ship = (function() {

    /**
     * Creates a new ship instance. Throws if you have not specified a valid
     * deployer or folder to ship.
     *
     * @param  {Object} opts - object with keys `root` and `deployer`
     */
    var contains_keys, find_shipfile, load_shipfile;

    function Ship(opts) {
      var err;
      this.root = path.resolve(opts.root);
      this.conf = opts.conf ? path.resolve(opts.conf) : void 0;
      this.deployer_name = opts.deployer;
      this.env = opts.env;
      this.shipfile = find_shipfile.call(this);
      try {
        this.deployer = require("./deployers/" + opts.deployer);
      } catch (_error) {
        err = _error;
        throw new Error(opts.deployer + " is not a valid deployer");
      }
      if (!fs.existsSync(this.root)) {
        throw new Error("path " + this.root + " does not exist");
      }
    }


    /**
     * Tests whether the ship instance has been configured or there is a shipfile
     * present that it can use to configure.
     *
     * @return {Boolean} - whether or not you need to configure the instance
     */

    Ship.prototype.is_configured = function() {
      if (this.config) {
        return true;
      }
      if (fs.existsSync(this.shipfile)) {
        return true;
      }
      return false;
    };


    /**
     * Manually sets the deployer's config/auth values.
     *
     * @param  {Object} data - deployer config values, see deployer docs for more
     */

    Ship.prototype.configure = function(data) {
      var config_keys, ref;
      config_keys = (ref = this.deployer.config) != null ? ref.required : void 0;
      if (config_keys && !contains_keys(config_keys, Object.keys(data))) {
        throw new Error("you must specify these keys: " + (config_keys.join(' ')));
      }
      if (data.ignore == null) {
        data.ignore = [];
      }
      data.ignore.push('**/ship*.conf');
      return this.config = data;
    };


    /**
     * Prompts the user for the deployer's config values via command line and sets
     * the resulting values as the instance's configuration.
     *
     * @return {Promise} promise for the configured values
     * @todo actually return a promise
     */

    Ship.prototype.config_prompt = function() {
      var ref;
      return prompt(this.deployer_name, (ref = this.deployer.config) != null ? ref.required : void 0).tap((function(_this) {
        return function(res) {
          return _this.config = res;
        };
      })(this));
    };


    /**
     * Writes the config values of the instance to `ship.conf` at the project
     * root, if the instance has been configured.
     *
     * @return {Promise} promise for the written config file
     */

    Ship.prototype.write_config = function(override) {
      var conf;
      if (!this.config) {
        return W.reject('deployer has not yet been configured');
      }
      conf = {};
      conf[this.deployer_name] = this.config;
      return nodefn.call(fs.writeFile, override || this.shipfile, yaml.safeDump(conf));
    };


    /**
     * Deploy the files at project root with the given deployer. Returns a promise
     * that emits progress events along the way.
     *
     * @return {Promise} promise for finished deploy
     */

    Ship.prototype.deploy = function(target) {
      var err;
      if (target == null) {
        target = this.root;
      }
      if (!this.config) {
        if (!fs.existsSync(this.shipfile)) {
          return W.reject('you must configure the deployer');
        }
        try {
          this.configure(load_shipfile.call(this));
        } catch (_error) {
          err = _error;
          return W.reject(err);
        }
      }
      return this.deployer(target, this.config);
    };


    /**
     * Given two arrays, ensure that the second array contains all values provided
     * in the first array. This is for checking to ensure all config values are
     * present.
     *
     * @private
     * @param  {Array} set1 - user-provided keys
     * @param  {Array} set2 - config-required keys
     * @return {Boolean} if all keys in set1 are also present in set2
     */

    contains_keys = function(set1, set2) {
      return _.isEqual(_.intersection(set2, set1).sort(), set1.sort());
    };


    /**
     * Determines the path to the Shipfile. It uses the conf option if present,
     * otherwise it looks in root, then the current working directory. If neither
     * exist, it sets the shipfile to be inside root.
     *
     * @private
     * @return {String} - path to shipfile
     */

    find_shipfile = function() {
      var p;
      p = (function(_this) {
        return function(dir) {
          return path.join(dir, "ship" + (_this.env ? '.' + _this.env : '') + ".conf");
        };
      })(this);
      if (this.conf) {
        return p(this.conf);
      }
      return _.find(_.map([this.root, process.cwd()], p), fs.existsSync) || p(process.cwd());
    };


    /**
     * Loads the configuration for the specified deployer from the shipfile.
     *
     * @private
     * @return {Object} - relevant config info
     */

    load_shipfile = function() {
      return yaml.safeLoad(fs.readFileSync(this.shipfile, 'utf8'))[this.deployer_name];
    };

    return Ship;

  })();

  module.exports = Ship;

}).call(this);
