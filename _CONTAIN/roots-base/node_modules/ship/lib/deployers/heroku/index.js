// Generated by CoffeeScript 1.9.1
(function() {
  var Heroku, W, api_url, check_app_status, create_tar, destroy, edge_create_build, fs, fstream, nodefn, path, request, tar, upload_tar, zlib;

  W = require('when');

  nodefn = require('when/node');

  fs = require('fs');

  path = require('path');

  Heroku = require('heroku-client');

  tar = require('tar');

  fstream = require('fstream');

  zlib = require('zlib');

  request = require('request');

  api_url = "https://burner-api.herokuapp.com";

  module.exports = function(root, opts) {
    var app, app_process, d, heroku, tar_process;
    d = W.defer();
    heroku = new Heroku({
      token: opts.api_key
    });
    app = heroku.apps(opts.name);
    tar_process = create_tar(root, opts.name).then(upload_tar);
    app_process = W(app.info())["catch"](function(err) {
      if (err.body.id !== 'not_found') {
        throw err;
      }
      return W(heroku.apps().create({
        name: opts.name,
        stack: 'cedar-14'
      })).then(function(res) {
        return app = res;
      }).tap(function() {
        if (opts.config) {
          return W(heroku.apps(app.name).configVars().update(opts.config));
        }
      });
    });
    W.all([tar_process, app_process]).then(function(res) {
      return edge_create_build(heroku, opts.name, res[0]);
    }).tap(function(res) {
      var d2, stream;
      d2 = W.defer();
      stream = request(res.stream_url);
      stream.on('end', d2.resolve);
      stream.on('error', d2.reject);
      stream.on('data', function(data) {
        return d.notify(String(data));
      });
      return d2.promise;
    }).tap(function(res) {
      var d2;
      d2 = W.defer();
      check_app_status(heroku, res.id, opts.name, d2);
      return d2.promise;
    }).then(function(res) {
      return W(heroku.apps(opts.name).builds(res.id).result().info());
    })["finally"](function() {
      return fs.unlinkSync(path.join(root, opts.name + ".tar.gz"));
    }).done((function(_this) {
      return function() {
        return d.resolve({
          deployer: 'heroku',
          url: "http://" + opts.name + ".herokuapp.com",
          destroy: destroy.bind(_this, heroku, opts.name)
        });
      };
    })(this), d.reject);
    return d.promise;
  };

  module.exports.config = {
    required: ['name', 'api_key']
  };


  /**
   * Create a new build using the edge api, which will return a streaming build
   * status url so that we can stream it correctly.
   *
   * @param  {Object} heroku - heroku instance
   * @param  {String} name - app name
   * @param  {String} id - uuid of the tarball
   * @return {Promise} - promise for the created app
   */

  edge_create_build = function(heroku, name, id) {
    return nodefn.call(heroku.request.bind(heroku), {
      method: 'POST',
      path: "/apps/" + name + "/builds",
      headers: {
        Accept: 'application/vnd.heroku+json; version=edge'
      },
      body: {
        source_blob: {
          url: api_url + "/" + id,
          version: id
        }
      }
    });
  };


  /**
   * Loops every second to check the build status. Once it is no longer 'pending',
   * allows the process to continue.
   *
   * @todo this should be eliminated, but in testing, sometimes the stream ending
   *       did not correctly indicate a full build, so it's here for security
   *
   * @param  {Object} heroku - heroku instance
   * @param  {Integer} id - app id
   * @param  {String} name - app name
   * @param  {Deferred} d - deferred object
   * @return {Promise} a promise that the app is no longer pending
   */

  check_app_status = function(heroku, id, name, d) {
    return heroku.apps(name).builds(id).info().then(function(res) {
      switch (res.status) {
        case 'pending':
          return check_app_status(heroku, id, name, d);
        default:
          return d.resolve();
      }
    });
  };


  /**
   * Given a directory path, create a tarball of that directory and drop it as
   * '{name}.tar' at the root of that directory.
   *
   * @private
   * @param {String} root - path to a directory
   * @return {Promise} promise for finished tarballization
   */

  create_tar = function(root, name) {
    var d, stream, tar_path;
    d = W.defer();
    tar_path = path.join(root, name + ".tar.gz");
    stream = fstream.Reader({
      path: root,
      type: 'Directory'
    }).pipe(tar.Pack({
      noProprietary: true
    })).pipe(zlib.createGzip()).pipe(fs.createWriteStream(tar_path));
    stream.on('close', d.resolve.bind(d, tar_path));
    stream.on('error', d.reject.bind(d));
    return d.promise;
  };


  /**
   * Uploads the tarball to a small private api that will host it for exactly one
   * download, then delete it. It's a patch for the fact that for some reason
   * rather than accepting a POST, heroku requires a url where they can download
   * the file. This is running on our server that we are paying for, and we
   * designed the mini api specifically for making this process smooth. Please do
   * not use this service for anything else or attempt to hack or abuse it. It
   * will make us take it down and will ruin the simplicity of this deployer for
   * everyone.
   *
   * @private
   * @return {Promise} a promise for the url that the tarball can be found at
   */

  upload_tar = function(tar_path) {
    var d, data, stream;
    d = W.defer();
    data = [];
    stream = fs.createReadStream(tar_path).pipe(request.post({
      rejectUnauthorized: false,
      url: api_url + "/new"
    }));
    stream.on('data', function(d) {
      return data.push(d);
    });
    stream.on('error', d.reject);
    stream.on('end', function() {
      return d.resolve(String(data.join('')));
    });
    return d.promise;
  };


  /**
   * Deletes the app from heroku.
   *
   * @private
   * @param  {Object} h - heroku instance
   * @param  {String} name - app name
   * @return {Promise} promise for the deleted app
   */

  destroy = function(h, name) {
    return W(h.apps(name)["delete"]());
  };

}).call(this);
